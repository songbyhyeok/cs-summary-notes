## 제3장 HTTP 정보는 HTTP 메시지에 있다
### 3.1 HTTP 메시지
- HTTP에서 교환하는 정보를 HTTP 메시지라고 한다.
  - 리퀘스트 메시지와 리스폰스 메시지가 있다.
- HTTP 1.1은 메시지 헤더/개행 문자(CR+LF)/메시지 바디로 구성되어 있다.
<br>

### 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조
![Image](https://github.com/user-attachments/assets/9c9b7a0d-b4a2-44c5-9403-303fec8c266c)  
**리퀘스트 라인**  
* 리퀘스트에 사용하는 메소드, URI, HTTP 버전이 포함된다.
**상태 라인**  
* 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함된다.
**헤더 필드**
* 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다.
* 일반 헤더, 리퀘스트 헤더, 리스폰스 헤더, 엔티티 헤더 필드 등 4종류가 있다.
<br>

### 3.3 인코딩으로 전송 효율을 높이다
- 인코딩은 다양한 목적을 위해 정보나 데이터를 특정 형식으로 변환하는 과정
- HTTP 데이터를 인코딩(변환)하면 전송 효율과 접근성을 높일 수 있다.

**메시지(message)**  
- HTTP 통신의 기본 단위
- 옥텟 시퀀스(Octet sequence)로 구성 및 전송

**엔티티(entity**)  
- HTTP에서 "entity"는 서버와 클라이언트 간에 페이로드로 전송되는 데이터
- 엔티티 헤더와, 엔티티 바디로 구성
    - 헤더: 엔티티와 관련된 메타데이터를 제공하는 http 헤더
        - 헤더 종류 - Content-Type, Content-Length, Content-Encoding  
    - 바디: http 메시지의 본문(html 페이지, 이미지 파일, json 데이터 등) 형식들을 담을 수 있다.
 
**콘텐츠 코딩**
- HTTP 메시지에서 전송되는 콘텐츠(본문 데이터)의 압축 방식이나 인코딩 방식을 지정하는 데 사용
- 콘텐츠 압축 종류
    - **Content-Encoding: gzip 헤더**
        - `zlib` 라이브러리 사용, GNU zip 알고리즘을 기반, 텍스트 파일 압축할 때 효과적
        - 압축률이 좋고, 웹에서 매우 자주 사용되며 대부분의 브라우저와 서버가 지원
        - 압축을 통해 웹 페이지의 로딩 속도를 빠르게 개선
    - **Content-Encoding: compress 헤더**
        - UNIX 시스템에서 사용하는 압축 방식, `LZW (Lempel–Ziv–Welch)` 알고리즘을 사용
        - 간단한 구현 방식
        - `gzip`이나 `deflate`보다 압축률이 낮고 속도가 느릴 수 있다.
        - 모든 브라우저나 서버가 `compress`를 지원하지 않기 때문에 상대적으로 덜 사용
    - **Content-Encoding: deflate 헤더**
        - `zlib` 라이브러리 사용, 압축된 데이터를 전달하는 방법
        - `gzip`보다 더 적은 메타데이터를 사용하여 더 가벼운 압축을 제공
        - HTTP 헤더와 같은 추가 정보가 없기 때문에 조금 더 가볍지만, 구형 브라우저 호환 문제가 있다.
    - **Content-Encoding: identity 헤더**
        - 압축되지 않은 원본 데이터를 그대로 전송하는 방법
        - 데이터를 압축하지 않으므로 빠르고, 데이터 손실이나 압축 오류가 없다.
        - 서버가 압축을 지원하지 않거나, 압축이 불필요한 경우에 사용
- 왜 압축을 사용해야 할까?
    - 이 압축 방법들을 통해 HTTP 응답의 크기를 줄여 네트워크 대역폭을 절약하고, 페이지 로딩 속도를 개선할 수 있기 때문

**청크 전송 코딩(chunked transfer coding)**  
- 엔티티 바디를 분할하는 기능
- HTTP/1.1에서 도입된 전송 인코딩 방식으로, 대용량 데이터를 효율적으로 처리하는 방법
- 이 방식은 전체 응답 본문을 한 번에 전송하지 않고, 여러 개의 작은 "청크"로 나누어 서버가 클라이언트로 전송하는 방법
- Transfer-Encoding: chunked 헤더 사용
- 동적 콘텐츠 전송
  - 서버가 요청을 처리하는 동안 데이터를 점진적으로 생성할 때 유용하다.
  - 실시간 데이터 스트리밍이나 긴 계산을 처리할 때, 청크 단위로 전송하기 때문에 효율적이다.
- 지연 최소화
  - 일부 데이터를 초기에 받을 수 있어, 초기 로딩 시간을 단축시킬 수 있다.
- 실시간 전송을 통해, 즉시 렌더링이 가능하지만, 브라우저 구조 특성상 완전한 콘텐츠를 보낼 때까지 렌더링을 지연시킨다.
- **청크 전송 방법**  
  ![Image](https://github.com/user-attachments/assets/ca4c7474-1cf6-4268-aac2-22446d5c5fcc)  
  1. 청크 단위로 데이터 전송: 데이터는 일정 크기로 나누어져 전송. 각 청크는 데이터 크기(16진수로 표현된 바이트 크기)와 해당 크기의 실제 데이터로 된다.
  2. 청크 종료 표시: 마지막 청크는 크기가 `0`인 청크로 전송되며, 이 때 서버는 데이터 전송이 완료되었음을 알린다. 이 "종료 청크" 뒤에는 `CRLF (Carriage Return + Line Feed)`가 이어진다.
  3. 청크 전송 코딩된 엔티티 바디는 클라이언트 측에서 디코딩 처리
<br>

### 3.4 여러 데이터를 보내는 멀티파트
**MIME(Multipurpose Internet Mail Extensions)**
- 이메일 시스템에서 텍스트 외의 데이터(예: 이미지, 비디오, 텍스트 외의 문자 집합 등)를 안전하게 전송할 수 있도록 만든 표준
- MEME 헤더를 사용하면 전송되는 데이터의 형식(type)과 인코딩 방식(encoding)을 명확히 지정할 수 있다.
- MIME 전송 방식은 ASCILL 문자만 포함할 수 있는, SMTP 같은 프로토콜을 사용하기 때문에, 이진 데이터인 이미지, 오디오 파일 등은 변환해야 한다.
**Multipart**
- MIME의 확장 사양에 포함된 기능
- 하나의 메시지에 여러 개의 파일을 첨부하거나 텍스트와 이미지를 함께 전송할 수 있다.
  - 메시지 바디에 엔티티를 여러 개 포함 시킬 수 있다.
<br>

### 3.5 일부분만 받는 레인지 리퀘스트
```
클라이언트 요청 (파일의 처음 1MB만 요청)
GET /largefile.zip HTTP/1.1
Host: example.com
Range: bytes=0-1048575

서버 응답 (처리된 범위만 응답)
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1048575/5242880
Content-Length: 1048576
```
- HTTP 프로토콜에서 특정 데이터의 일부만 요청하는 기능
  - 클라이언트가 중단된 지점부터 엔터티의 범위를 지정해 요청할 수 있다.
  - 대용량 파일이나 스트리밍 방식에서 사용
<br>

### 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션(**Content Negotiation**)
- 서버가 제공할 수 있는 다양한 콘텐츠 형식 중에서 클라이언트가 원하는 형식을 협상하여 선택하는 과정(교섭)
- 콘텐츠 협상은 미디어 타입, 언어, 문서의 캐릭터셋, 지역화(Locale) 등 여러 요소를 기준으로 협상된다.
- 클라이언트의 요구에 맞춰 콘텐츠를 제공 목적의 구조
  - ex 클라이언트가 HTML 문서, JSON, XML 등의 형식 중 하나를 요청할 수 있도록 하여, 서버는 이를 제공하는 방식
  - ex 특정 URL에 대해 영어권에 사용자는 영어로 이루어진 리소스를 받길 원할 것이고, 스페인권 사용자는 스페인어로 구성된 리소스를 요구
- 클라이언트가 요구하는 형식, 언어, 압축 방식 등에 맞춰 콘텐츠를 제공하므로 최적화된 사용자 경험을 제공한다.

**클라이언트 주도 협상**  
- 클라이언트 측에서 협상하는 방식
- 서버가 요청을 받았을 때 가능한 페이지 목록을 응답으로 전달하고 클라이언트가 원하는 것을 선택하도록 하는 방법
- 브라우저에 표시된 선택지 중에서 유저가 수동적으로 선택
- 사용자가 원하는 내용을 얻기까지 최소 두 번의 요청이 필요하고, 이로 인해 대기시간이 증가한다
- 각 페이지에 대한 여러 개의 URL이 필요하다.

**서버 주도 협상**  
- 서버 측에서 협상하는 방식
- 서버는 요청 헤더 정보를 기반으로 협상
- 여러 버전의 문서를 서버에 가지고 있어야 하고 요청 헤더에 따라 적합한 리소스를 선택에 응답해 주어야 한다

**투명 협상**  
- 클라이언트와 서버 간의 협상에서 사용자가 특정 협상 과정을 명시적으로 인지하지 않고 서버가 자동으로 최적의 콘텐츠를 제공하는 방식
  - 사용자가 어떤 형식이나 언어를 요구하거나 협상하는 것을 알지 못하는 상태에서 서버가 **자동적으로 최적의 콘텐츠**를 제공하는 방식
